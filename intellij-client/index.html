<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Klassresan</title>
    <script src="https://unpkg.com/viz.js@2.1.2/viz.js"></script>
    <script src="https://unpkg.com/viz.js@2.1.2/full.render.js"></script>
    <style>
        #status {
          width: 12px;
          height: 12px;
          border-radius: 50%;
          display: inline-block;
          margin-left: 5px;
        }
        #status.connected { background: #0c0; }
        #status.disconnected { background: red; }

        #graph svg {
            transform: scale(0.75);
            transform-origin: top left;
        }

        #dot {
          /* dot code is written but hidden */
          display: none;
        }

        #settings {
          display: none;
          margin: 10px 0;
          padding: 10px;
          border: 1px solid #ccc;
          background: #f9f9f9;
        }
        #settings textarea {
          width: 100%;
          height: 50px;
        }
    </style>
</head>
<body>
<h3>Klassresan <span id="status" class="disconnected"></span></h3>
<button onclick="toggleSettings()">⚙️ Settings</button>
<div id="settings">
  <label>Server URL (empty = localhost):<br>
    <input type="text" id="serverUrl">
  </label>
  <br><br>
  <label>Ignored Classes (comma separated):<br>
    <textarea id="ignoredClasses"></textarea>
  </label>
  <br><br>
  <label>Ignored Projects/Packages (comma separated):<br>
    <textarea id="ignoredProjects"></textarea>
  </label>
  <br><br>
  <button onclick="saveSettings()">Save Settings</button>
</div>

<div id="graph"></div>
<pre id="dot"></pre>
<a href="javascript:clear();">clear</a>

<script>
let ws;
let nodes = new Map();        // fileName:method
let edges = new Set();        // from->to
let clusters = new Map();     // file -> [method]
let activeDebuggerNode = null;
let activeEditorNode = null;
let activeHierarchyNode = null;

let settings = {
  serverUrl: "",
  ignoredClasses: [],
  ignoredProjects: []
};

function loadSettings() {
  const raw = localStorage.getItem("klassresanSettings");
  if (raw) {
    try {
      settings = JSON.parse(raw);
    } catch (e) {
      console.error("Failed to parse settings", e);
    }
  }
  document.getElementById("serverUrl").value = settings.serverUrl || "";
  document.getElementById("ignoredClasses").value = (settings.ignoredClasses || []).join(", ");
  document.getElementById("ignoredProjects").value = (settings.ignoredProjects || []).join(", ");
}

function saveSettings() {
  settings.serverUrl = document.getElementById("serverUrl").value.trim();
  settings.ignoredClasses = document.getElementById("ignoredClasses").value.split(",").map(s => s.trim()).filter(Boolean);
  settings.ignoredProjects = document.getElementById("ignoredProjects").value.split(",").map(s => s.trim()).filter(Boolean);
  localStorage.setItem("klassresanSettings", JSON.stringify(settings));
  alert("Settings saved. Reload to reconnect.");
}

function toggleSettings() {
  const el = document.getElementById("settings");
  el.style.display = el.style.display === "none" ? "block" : "none";
}

function connect() {
  console.log('connect')
  const url = settings.serverUrl ? settings.serverUrl : "localhost:8091";
  ws = new WebSocket(`ws://${url}`);
  // ws = new WebSocket(`ws://${location.host}`);
  ws.onopen = () => setStatus(true);
  ws.onclose = () => {
    setStatus(false);
    setTimeout(connect, 2000);
  };
  ws.onmessage = (event) => {
    try {
      const trace = JSON.parse(event.data);
      console.log('trace', trace)
      handleMessage(trace);
    } catch (err) {
      console.error("Invalid message", err);
    }
  };
}

function getClusterId(frame) {
  return `${frame.pkg}:${frame.clazz}`;
}

function getKey(frame) {
  return `${frame.pkg}.${frame.clazz}:${frame.method}`;
}

function getEdgeKey(frame0, frame1) {
  return `${getKey(frame1)}->${getKey(frame0)}`;
}

function handleMessage(trace) {

  if (!Array.isArray(trace) || trace.length === 0) return;

  // ignored projects check
  for (const frame of trace) {
    if (settings.ignoredProjects.some(pkg => frame.pkg && frame.pkg.startsWith(pkg))) {
      return; // ignore whole trace
    }
  }

  // filter unwanted frames
  const validTrace = trace.filter(node =>
       !settings.ignoredClasses.includes(node.clazz)
    && node.method !== 'unknown_method'
    && node.line !== -1
  )

  if (validTrace.length === 0) return;

  const topFrame = validTrace[0]
  switch (topFrame.source) {
    case "debugger": activeDebuggerNode = getKey(topFrame); break;
    case "hierarchy": activeHierarchyNode = getKey(topFrame); break;
    case "editor": activeEditorNode = getKey(topFrame); break;
  }

  for (let i = 0; i < validTrace.length; i++) {
    const frame = validTrace[i];
    const id = getClusterId(frame)
    const key = getKey(frame)

    if (i > 0) { // have previous node, link it
      const edgeKey = getEdgeKey(validTrace[i-1], validTrace[i])
      edges.add(edgeKey);
    }

    if (!nodes.has(key)) {
      nodes.set(key, frame);
    }

    if (!clusters.has(id)) clusters.set(id, []);
    if (!clusters.get(id).includes(key)) clusters.get(id).push(key);
  }

  renderGraph();
}

function setStatus(ok) {
  const el = document.getElementById("status");
  el.className = ok ? "connected" : "disconnected";
}

function sanitize(str) {
  return str.replace(/[^a-zA-Z0-9_]/g, "_");
}

function clear() {
  nodes = new Map();
  edges = new Set();
  clusters = new Map();
  activeDebuggerNode = null;
  activeHierarchyNode = null;
  activeEditorNode = null;
  renderGraph()
}

function renderGraph() {
  let dot = 'digraph G {\n  rankdir=LR;\n  node [shape=ellipse];\n\n'; // rankdir left to right
  const resourceClusters = []

  // force resources to stay on the edge with invisible __caller node
  dot+='__caller [style=invis]\n'
  for (const [key, frame] of nodes.entries()) {
    const isResource = frame.clazz.includes('Resource')
    if (isResource) {
      dot+= `__caller -> "${key}" [color=\"#cccccc\" penwidth=0]\n`
    }
  }

  for (const [clusterId, methods] of clusters.entries()) {
    let activeClusterEditor = false
    let activeClusterHierarchy = false
    for (const key of methods) {
      activeClusterEditor = activeClusterEditor || key === activeEditorNode
      activeClusterHierarchy = activeClusterHierarchy || key === activeHierarchyNode
    }

    const clusterIdTag = `cluster_${sanitize(clusterId)}`
    const clusterName = clusterId.split(':')[1]
    dot += `  subgraph ${clusterIdTag} {\n    label="${clusterName}";\n`;

    if (activeClusterEditor) {
      dot+="style=filled;"
      dot+="color=\"#ff0000\";"
      dot+="fillcolor=\"#ffdddd\";"
      dot+="penwidth=2;"
    } else if (activeClusterHierarchy) {
      dot+="color=\"#00aa00\";"
      dot+="style=filled;"
      dot+="fillcolor=\"#eeffee\";"
      dot+="penwidth=2;"
    }
    
    dot+='    { rank=same\n'
    dot+= '      edge [constraint=false];\n'
    
    for (const key of methods) {
      const frame = nodes.get(key);
      const activeDebugger = key === activeDebuggerNode
      const activeEditor = key === activeEditorNode

      const isResource = frame.clazz.includes('Resource')

      const color = activeDebugger ? "color=blue" : activeEditor ? "color=red" : ""
      const fillcolor = activeDebugger ? "fillcolor=\"#00ccff\"" : activeEditor ? "fillcolor=\"#ffcccc\"" : isResource ? "fillcolor=\"#cccccc\"" : ""
      const penwidth = activeEditor && activeDebugger ? "penwidth=4" : activeEditor || activeDebugger ? "penwidth=2" : ""
      const style = activeDebugger || activeEditor || isResource ? "style=filled" : ""
      const shape = isResource ? "shape=box" : ""

      dot += `      "${key}" [label="${frame.method}" ${color} ${penwidth} ${fillcolor} ${style} ${shape}];\n`;
    }
    dot += '    }\n'; // same
    dot += '  }\n\n';
  }

  // edges
  for (const edge of edges) {
    const [from, to] = edge.split("->");
    dot += `  "${from}" -> "${to}";\n`;
  }

  dot += '}';

  // show the dot output
  document.getElementById('dot').innerHTML = dot

  try {
    const viz = new Viz();
    viz.renderSVGElement(dot).then(svg => {
      const graphDiv = document.getElementById("graph");
      graphDiv.innerHTML = "";
      graphDiv.appendChild(svg);
    }).catch(err => console.error("Viz.js render error", err));
  } catch (e) {
    console.error("DOT build failed", e);
  }
}

loadSettings();
connect();
</script>
<!-- sample data -->
<!-- <script src="sample.js"></script> -->

</body>
</html>
